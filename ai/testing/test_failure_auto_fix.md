# 测试失败自动修复指南

> **文档说明**：本文档分为两部分
> - **第一部分（Claude 执行指南）**：供 Claude 在执行自动修复时参考的详细操作步骤
> - **第二部分（用户理解案例）**：供用户理解系统工作原理的简化示例

---

# 第一部分：Claude 执行指南

## 概述

当测试失败时，Claude 作为协调者，负责分析失败原因、生成修复 Prompt、委托 Coder 修复、验证结果，并控制重试循环。

## 核心原则

1. **安全第一**：最大重试 3 次，避免无限循环
2. **智能分析**：使用错误分类系统判断是否可自动修复
3. **渐进式修复**：每次修复后立即验证，失败则重新分析
4. **人工介入点**：超过最大重试次数后停止，请求人工介入
5. **完整记录**：记录所有修复尝试和结果

## 适用场景判断

### ✅ 可自动修复

- 简单的代码逻辑错误
- 类型错误（类型不匹配、参数类型错误）
- 断言失败（预期值与实际值不匹配）
- 边界条件处理不当
- 返回值错误

### ❌ 不可自动修复

- 架构级问题（需要重新设计、涉及多个模块）
- 环境问题（依赖缺失、配置错误）
- 复杂的业务逻辑错误

## 执行步骤

### 步骤 1：捕获测试失败信息

**Claude 需要收集**：
- 失败的测试用例名称（如 `tests/test_calculator.py::test_add`）
- 完整的错误信息和堆栈跟踪
- 测试输出的最后 50 行
- 相关源代码文件路径

**执行命令示例**：
```bash
pytest tests/test_module.py::test_function -v
```

### 步骤 2：错误分类和可修复性判断

**Claude 需要判断**：
1. 参考 `ai/error-handling/error_classification.md` 判断错误类型
2. 是否属于"代码错误"类型？
3. 是否属于"简单代码错误"（逻辑、类型、断言）？

**判断流程**：
```
错误类型 == 代码错误？
  ↓ 是
是简单代码错误？
  ↓ 是
✅ 可以自动修复，继续步骤 3
  ↓ 否
❌ 不可自动修复，提供修复建议并等待人工处理
```

### 步骤 3：分析失败原因

**Claude 需要执行**：
1. 使用 Read 工具读取失败的测试用例代码
2. 使用 Read 工具读取被测试的源代码
3. 分析错误信息和堆栈跟踪
4. 识别问题根源（如：返回值错误、类型不匹配、边界条件未处理）

**分析要点**：
- 测试期望什么？（预期值）
- 代码实际返回什么？（实际值）
- 差异的根本原因是什么？

### 步骤 4：生成修复 Prompt

**Claude 需要生成的 Prompt 模板**：

```
测试失败自动修复任务（第 {retry_count} 次尝试）

**失败测试**：{test_name}
**错误类型**：{error_type}
**错误信息**：
{error_message}

**根本原因分析**：
{root_cause_analysis}

**需要修复的文件**：{file_path}

**修复要求**：
1. 修复 {file_path} 中的 {function_or_class_name}
2. 具体修复内容：{specific_fix_description}
3. 确保修复后测试通过
4. 不要修改测试用例本身
5. 保持代码风格一致

**验证方式**：
运行测试命令：{test_command}
```

**Prompt 生成要点**：
- 明确指出问题根源
- 提供具体的修复方向
- 如果是第 2/3 次尝试，说明之前的尝试为什么失败
- 保持 Prompt 简洁但信息完整

### 步骤 5：调用 Coder 执行修复

**Claude 需要执行**：

使用 `mcp__ccg__coder` 工具调用 Coder：

```json
{
  "PROMPT": "生成的修复 Prompt",
  "cd": "项目根目录路径",
  "SESSION_ID": "保持与之前相同的 SESSION_ID",
  "timeout": 900,
  "max_duration": 900
}
```

**关键点**：
- 必须保持相同的 SESSION_ID，让 Coder 了解修复历史
- 超时设置为 15 分钟（900 秒）
- 等待 Coder 完成修复

### 步骤 6：验证修复结果

**Claude 需要执行**：

1. 使用 Bash 工具重新运行测试：
```bash
pytest tests/test_module.py::test_function -v
```

2. 检查测试结果：
   - ✅ 测试通过 → 修复成功，跳转到步骤 8（报告成功）
   - ❌ 测试失败 → 继续步骤 7（检查重试次数）

### 步骤 7：重试逻辑控制

**Claude 需要判断**：

```
当前重试次数 < 3？
  ↓ 是
  记录本次失败原因
  重试次数 + 1
  返回步骤 3（重新分析失败原因）

  ↓ 否（已达到 3 次）
  停止自动修复
  生成人工介入报告（步骤 9）
```

**重试时的注意事项**：
- 保持相同的 SESSION_ID
- 在新的 Prompt 中说明之前的尝试为什么失败
- 提供不同的修复方向

### 步骤 8：报告修复成功

**Claude 需要输出**：

```
✅ 测试失败自动修复成功

**失败测试**：{test_name}
**修复尝试次数**：{retry_count} 次
**修复内容**：{fix_summary}
**验证结果**：测试通过

可以继续后续流程（Claude 验收或 Codex 审核）。
```

### 步骤 9：生成人工介入报告

**Claude 需要输出**：

```
❌ 测试失败自动修复失败，需要人工介入

**失败测试**：{test_name}
**尝试次数**：3 次
**最后错误**：{last_error_message}

**修复历史**：
1. 第 1 次尝试：{attempt_1_summary} → 失败原因：{failure_reason_1}
2. 第 2 次尝试：{attempt_2_summary} → 失败原因：{failure_reason_2}
3. 第 3 次尝试：{attempt_3_summary} → 失败原因：{failure_reason_3}

**问题分析**：
{problem_analysis}

**建议**：
- {suggestion_1}
- {suggestion_2}
- {suggestion_3}

请人工分析并修复此问题。
```

## 与 CCG 工作流集成

### 集成点 1：Coder 执行后自动测试

**触发时机**：Coder 完成代码实现后

**Claude 执行流程**：
1. 自动运行测试命令
2. 如果测试失败，判断是否可自动修复
3. 如果可以，启动自动修复循环（步骤 1-9）
4. 修复成功后，继续 Claude 验收流程

**关键点**：
- 保持 Coder 的 SESSION_ID
- 确保上下文连续

### 集成点 2：Claude 验收阶段

**触发时机**：Claude 验收代码质量时发现测试失败

**Claude 执行流程**：
1. 判断是否可自动修复
2. 如果可以，启动自动修复循环
3. 修复成功后，继续验收其他检查项

**验收检查项**：
- ✅ 代码风格符合规范
- ✅ 所有测试通过（如失败则自动修复）
- ✅ 覆盖率达标
- ✅ 无明显代码质量问题

### 集成点 3：Codex 审核前确保测试通过

**触发时机**：准备调用 Codex 审核前

**Claude 执行流程**：
1. 运行完整测试套件
2. 如果测试失败，启动自动修复循环
3. 修复成功后，才调用 Codex 审核

**强制规则**：
- ❌ 禁止在测试失败时调用 Codex 审核
- ✅ 必须先自动修复测试失败
- ✅ 所有测试通过后才能进入审核阶段

## 安全机制和限制

### 硬性限制

1. **最大重试次数：3 次**
   - 超过 3 次自动停止
   - 避免无限循环

2. **单次修复超时：15 分钟**
   - Coder 执行超时限制
   - 超时视为修复失败

3. **禁止修改测试用例**
   - 只修复源代码
   - 保持测试的权威性

### 软性限制

1. **只修复简单代码错误**
   - 不处理架构级问题
   - 不处理环境问题

2. **保持代码风格一致**
   - 遵循现有代码规范
   - 最小化改动范围

3. **保持 SESSION_ID 连续**
   - 让 Coder 了解修复历史
   - 避免重复相同的错误

---

# 第二部分：用户理解案例

> **说明**：以下案例用于帮助用户理解自动修复系统的工作原理，采用简化的叙述方式。

## 案例 1：简单断言失败（一次修复成功）

### 场景描述

用户实现了一个计算器的 `add` 函数，但测试失败了。

### 测试失败信息

```
FAILED tests/test_calculator.py::test_add
AssertionError: assert 5 == 6
Expected: 6, Got: 5
```

### 自动修复过程

**Claude 分析**：
- 测试期望 `add(2, 3)` 返回 6
- 实际返回 5
- 读取源代码发现：`def add(a, b): return a + b - 1`
- 问题：多减了 1

**Claude 生成 Prompt 给 Coder**：
```
修复 src/calculator.py 中的 add 函数，
移除多余的 -1 操作，确保 add(2, 3) 返回 5。
```

**Coder 修复**：
```python
def add(a, b):
    return a + b  # 移除了 -1
```

**Claude 验证**：
- 重新运行测试：✅ 通过
- 修复成功！

### 结果

✅ 第 1 次尝试就修复成功，用户无需手动干预。

## 案例 2：类型错误（需要多次修复）

### 场景描述

用户实现了一个处理用户输入的函数，但没有考虑各种边界情况。

### 第 1 次尝试

**测试失败**：
```
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

**Claude 分析**：参数 b 可能是字符串，需要类型转换

**Coder 修复**：添加 `int(b)` 类型转换

**验证结果**：❌ 仍然失败（None 值导致错误）

### 第 2 次尝试

**Claude 重新分析**：发现 None 值未处理

**Coder 修复**：添加 None 检查

**验证结果**：❌ 仍然失败（空字符串转换失败）

### 第 3 次尝试

**Claude 重新分析**：发现空字符串 `""` 无法转换为 int

**Coder 修复**：添加空字符串默认值处理

**验证结果**：✅ 通过

### 结果

✅ 通过 3 次渐进式修复，最终解决了所有边界情况问题。

## 案例 3：架构级问题（无法自动修复）

### 场景描述

用户的用户注册功能出现数据库并发问题。

### 测试失败信息

```
IntegrityError: duplicate key value violates unique constraint
```

### 自动修复尝试

**第 1 次尝试**：Coder 添加唯一性检查 → ❌ 失败

**第 2 次尝试**：Coder 修改数据库约束 → ❌ 失败

**第 3 次尝试**：Coder 修改事务隔离级别 → ❌ 失败

### Claude 生成人工介入报告

```
❌ 测试失败自动修复失败，需要人工介入

**失败测试**：test_user_authentication
**尝试次数**：3 次

**问题分析**：
问题涉及数据库架构设计和并发控制策略，
超出了简单代码修复的范围。

**建议**：
- 重新设计用户注册流程的并发控制
- 考虑使用分布式锁或乐观锁
- 建议人工分析并发场景
```

### 结果

❌ 达到最大重试次数，系统停止自动修复，等待用户人工处理。

## 总结

### 核心价值

1. **提高开发效率**
   - 自动修复简单代码错误
   - 减少人工干预
   - 加快迭代速度

2. **保证代码质量**
   - 确保测试通过后才继续
   - 禁止提交失败代码
   - 保持测试的权威性

3. **安全可控**
   - 最大重试 3 次
   - 及时请求人工介入
   - 完整的修复记录

### 适用范围

**✅ 适合自动修复**：
- 简单的逻辑错误
- 类型错误和断言失败
- 边界条件处理不当
- 返回值错误

**❌ 不适合自动修复**：
- 架构级问题
- 环境配置问题
- 复杂的业务逻辑错误
- 需要重新设计的问题

### 与其他系统的关系

- **错误分类系统**：`ai/error-handling/error_classification.md` - 判断错误类型
- **重试策略**：`ai/error-handling/retry_strategy.md` - 控制重试逻辑
- **恢复建议**：`ai/error-handling/recovery_suggestions.md` - 提供修复建议
- **测试失败处理**：`ai/testing/test_failure_handling.md` - 标准处理流程

### 使用建议

1. **优先使用自动修复**：对于简单代码错误，让系统自动处理
2. **监控修复效果**：关注自动修复成功率和常见失败类型
3. **及时人工介入**：遇到复杂问题时不要强行自动修复
4. **持续优化**：根据修复历史优化 Prompt 和策略
