# 测试失败自动修复指南

## 概述

测试失败自动修复系统能够自动分析测试失败原因，生成修复方案，委托 Coder 修复代码，并自动验证修复结果，实现测试失败的自动化闭环处理。

## 核心原则

1. **安全第一**：设置最大重试次数（3次），避免无限循环
2. **智能分析**：使用错误分类系统判断是否可自动修复
3. **渐进式修复**：每次修复后立即验证，失败则重新分析
4. **人工介入点**：超过最大重试次数后停止，请求人工介入
5. **完整记录**：记录所有修复尝试和结果，便于调试

## 适用场景

### ✅ 可自动修复的场景

1. **代码逻辑错误**
   - 简单的逻辑错误
   - 边界条件处理不当
   - 返回值错误

2. **类型错误**
   - 类型不匹配
   - 参数类型错误
   - 返回类型错误

3. **断言失败**
   - 预期值与实际值不匹配
   - 状态码错误
   - 数据格式错误

### ❌ 不可自动修复的场景

1. **架构级问题**
   - 需要重新设计
   - 涉及多个模块

2. **环境问题**
   - 依赖缺失
   - 配置错误

## 自动修复流程

### 步骤 1：捕获测试失败

**收集信息**：
- 失败的测试用例名称
- 错误信息和堆栈跟踪
- 测试日志（最后 50 行）
- 相关代码文件路径

### 步骤 2：错误分类和可修复性判断

**使用错误分类系统**：
- 参考 `ai/error-handling/error_classification.md`
- 判断错误类型（代码错误/环境错误/其他）

**可修复性判断**：
```
是代码错误？
  ↓ 是
是简单的代码错误？
  ↓ 是
可以自动修复 ✅
```

### 步骤 3：分析失败原因

**深度分析**：
1. 读取失败的测试用例代码
2. 读取被测试的源代码
3. 分析错误信息和堆栈跟踪
4. 识别问题根源

### 步骤 4：生成修复 Prompt

**Prompt 模板**：
```
测试失败自动修复任务

**失败测试**：{test_name}
**错误信息**：{error_message}
**失败原因**：{root_cause}

**修复要求**：
1. 修复 {file_path} 中的代码错误
2. 确保测试通过
3. 不要修改测试用例本身
```

### 步骤 5：委托 Coder 修复

**调用 Coder**：
- 使用生成的 Prompt
- 保持 SESSION_ID
- 设置合理超时（15分钟）

### 步骤 6：验证修复结果

**重新运行测试**：
```bash
pytest tests/test_module.py::test_function -v
```

**结果判断**：
- ✅ 测试通过 → 修复成功
- ❌ 测试失败 → 检查重试次数

### 步骤 7：重试逻辑和循环控制

**检查重试次数**：
- 当前重试次数 < 3 → 返回步骤 3 重新分析
- 当前重试次数 ≥ 3 → 停止，请求人工介入

**循环控制流程**：
```
重试次数 = 0
while 重试次数 < 3:
    分析失败原因
    生成修复 Prompt
    委托 Coder 修复
    运行测试
    if 测试通过:
        报告成功
        break
    重试次数++

if 重试次数 ≥ 3:
    报告失败，需要人工介入
```

**人工介入报告模板**：
```
测试失败自动修复失败

**失败测试**：{test_name}
**尝试次数**：3 次
**最后错误**：{last_error}

**修复历史**：
1. 第 1 次尝试：{attempt_1_summary}
2. 第 2 次尝试：{attempt_2_summary}
3. 第 3 次尝试：{attempt_3_summary}

**建议**：
- 问题可能涉及架构级改动
- 建议人工分析根本原因
- 参考修复历史避免重复尝试
```

## 使用示例

### 示例 1：简单断言失败自动修复

**场景**：单元测试断言失败

**测试失败信息**：
```
FAILED tests/test_calculator.py::test_add
AssertionError: assert 5 == 6
Expected: 6, Got: 5
```

**自动修复流程**：

1. **捕获失败**：
   - 测试：`test_add`
   - 错误：断言失败，预期 6 实际 5

2. **错误分类**：
   - 类型：代码错误（断言失败）
   - 可修复性：✅ 可自动修复

3. **分析原因**：
   - 读取测试代码：`assert add(2, 3) == 6`
   - 读取源代码：`def add(a, b): return a + b - 1`
   - 根因：返回值计算错误（多减了 1）

4. **生成 Prompt**：
```
测试失败自动修复任务

**失败测试**：test_add
**错误信息**：AssertionError: assert 5 == 6
**失败原因**：add 函数返回值计算错误，多减了 1

**修复要求**：
1. 修复 src/calculator.py 中的 add 函数
2. 移除多余的 -1 操作
3. 确保测试通过
```

5. **委托 Coder 修复**：
   - Coder 修改代码：`def add(a, b): return a + b`

6. **验证结果**：
   - 运行测试：✅ 通过
   - 修复成功

### 示例 2：需要多次重试的场景

**场景**：类型错误需要多次修复

**第 1 次尝试**：
- 测试失败：`TypeError: unsupported operand type(s) for +: 'int' and 'str'`
- Coder 修复：添加类型转换 `int(b)`
- 验证：❌ 仍然失败（边界条件未处理）

**第 2 次尝试**：
- 重新分析：发现 None 值未处理
- Coder 修复：添加 None 检查
- 验证：❌ 仍然失败（空字符串未处理）

**第 3 次尝试**：
- 重新分析：发现空字符串转换失败
- Coder 修复：添加空字符串默认值
- 验证：✅ 通过

**总结**：通过 3 次渐进式修复，最终解决问题。

### 示例 3：超过最大重试次数的场景

**场景**：架构级问题无法自动修复

**第 1-3 次尝试**：
- 所有尝试都失败
- 问题涉及多个模块的交互
- 需要重新设计数据流

**人工介入报告**：
```
测试失败自动修复失败

**失败测试**：test_user_authentication
**尝试次数**：3 次
**最后错误**：IntegrityError: duplicate key value

**修复历史**：
1. 第 1 次：尝试添加唯一性检查 → 失败
2. 第 2 次：尝试修改数据库约束 → 失败
3. 第 3 次：尝试修改事务隔离级别 → 失败

**建议**：
- 问题涉及数据库架构设计
- 建议人工分析并发控制策略
- 可能需要重新设计用户注册流程
```

## 与 CCG 工作流集成

### 集成点 1：Coder 执行后自动测试

**流程**：
```
Coder 完成代码实现
    ↓
自动运行测试
    ↓
测试失败？
  ↓ 是
启动自动修复循环
  ↓
修复成功？
  ↓ 是
继续 Claude 验收
```

**实现方式**：
- Coder 执行完成后，Claude 自动运行测试命令
- 如果测试失败，Claude 启动自动修复流程
- 保持 Coder 的 SESSION_ID，确保上下文连续

### 集成点 2：Claude 验收阶段

**流程**：
```
Claude 验收代码质量
    ↓
发现测试失败？
  ↓ 是
判断是否可自动修复
  ↓ 是
启动自动修复循环
  ↓
修复成功后继续验收
```

**验收检查项**：
- ✅ 代码风格符合规范
- ✅ 所有测试通过（如失败则自动修复）
- ✅ 覆盖率达标
- ✅ 无明显代码质量问题

### 集成点 3：Codex 审核前确保测试通过

**流程**：
```
准备调用 Codex 审核
    ↓
运行完整测试套件
    ↓
测试失败？
  ↓ 是
启动自动修复循环
  ↓
修复成功？
  ↓ 是
调用 Codex 审核
```

**原则**：
- ❌ 禁止在测试失败时调用 Codex 审核
- ✅ 必须先自动修复测试失败
- ✅ 所有测试通过后才能进入审核阶段

### Claude 的职责

**作为协调者**：
1. 监控测试执行结果
2. 判断是否启动自动修复
3. 控制重试次数和循环
4. 决定何时请求人工介入

**决策流程**：
```
测试失败
    ↓
Claude 分析错误类型
    ↓
是否可自动修复？
  ↓ 是
启动自动修复循环
  ↓ 否
提供修复建议，等待人工处理
```

## 安全机制和限制

### 硬性限制

1. **最大重试次数：3 次**
   - 超过 3 次自动停止
   - 避免无限循环
   - 保护系统资源

2. **单次修复超时：15 分钟**
   - Coder 执行超时限制
   - 避免长时间阻塞
   - 超时视为修复失败

3. **禁止修改测试用例**
   - 只修复源代码
   - 不允许修改测试来"通过"
   - 保持测试的权威性

### 软性限制

1. **只修复简单代码错误**
   - 逻辑错误、类型错误、断言失败
   - 不处理架构级问题
   - 不处理环境问题

2. **保持代码风格一致**
   - 遵循现有代码规范
   - 不引入新的依赖
   - 最小化改动范围

3. **优先使用现有模式**
   - 参考项目中的类似代码
   - 不引入新的设计模式
   - 保持代码一致性

### 监控和记录

1. **记录所有修复尝试**
   - 每次尝试的 Prompt
   - Coder 的修改内容
   - 测试结果
   - 失败原因

2. **生成修复报告**
   - 成功：记录修复方法
   - 失败：记录失败历史和建议

3. **指标收集**
   - 自动修复成功率
   - 平均修复次数
   - 常见失败类型

## 最佳实践

### 1. 渐进式修复

**原则**：每次只修复一个问题，立即验证

**好的做法**：
```
第 1 次：修复类型错误 → 验证
第 2 次：修复边界条件 → 验证
第 3 次：修复空值处理 → 验证
```

**不好的做法**：
```
一次性修复所有问题 → 验证失败 → 不知道哪里错了
```

### 2. 保持上下文连续

**原则**：使用相同的 SESSION_ID，让 Coder 了解修复历史

**实现**：
- 第 1 次修复：使用 SESSION_ID_A
- 第 2 次修复：继续使用 SESSION_ID_A
- 第 3 次修复：继续使用 SESSION_ID_A

**好处**：
- Coder 知道之前尝试过什么
- 避免重复相同的错误修复
- 提高修复成功率

### 3. 及时停止

**原则**：识别不可自动修复的场景，及时请求人工介入

**停止信号**：
- ✅ 3 次尝试都失败
- ✅ 错误信息没有变化（陷入循环）
- ✅ 错误涉及架构级问题
- ✅ 错误涉及环境配置

**不要**：
- ❌ 无限重试
- ❌ 强行修改测试用例来"通过"
- ❌ 忽略错误继续执行

## 总结

测试失败自动修复系统通过智能分析、渐进式修复和安全机制，实现了测试失败的自动化闭环处理。

### 核心价值

1. **提高开发效率**
   - 自动修复简单代码错误
   - 减少人工干预
   - 加快迭代速度

2. **保证代码质量**
   - 确保测试通过后才继续
   - 禁止提交失败代码
   - 保持测试的权威性

3. **安全可控**
   - 最大重试次数限制
   - 及时请求人工介入
   - 完整的修复记录

### 适用范围

**适合自动修复**：
- ✅ 简单的逻辑错误
- ✅ 类型错误和断言失败
- ✅ 边界条件处理不当
- ✅ 返回值错误

**不适合自动修复**：
- ❌ 架构级问题
- ❌ 环境配置问题
- ❌ 复杂的业务逻辑错误
- ❌ 需要重新设计的问题

### 与其他系统的关系

- **错误分类系统**：`ai/error-handling/error_classification.md` - 判断错误类型
- **重试策略**：`ai/error-handling/retry_strategy.md` - 控制重试逻辑
- **恢复建议**：`ai/error-handling/recovery_suggestions.md` - 提供修复建议
- **测试失败处理**：`ai/testing/test_failure_handling.md` - 标准处理流程

### 使用建议

1. **优先使用自动修复**：对于简单代码错误，让系统自动处理
2. **监控修复效果**：关注自动修复成功率和常见失败类型
3. **及时人工介入**：遇到复杂问题时不要强行自动修复
4. **持续优化**：根据修复历史优化 Prompt 和策略
