# 测试失败自动修复指南

> **文档说明**：本文档分为两部分
> - **第一部分（Claude 执行指南）**：供 Claude 在执行自动修复时参考的详细操作步骤
> - **第二部分（用户理解案例）**：供用户理解系统工作原理的简化示例

> **策略层级**：
> - **本文档**：单层 Coder 修复（最多 3 次重试）- 适合简单问题
> - **高级策略**：多层级修复（智能诊断 + 按领域分流 + 3层9次 + 人工介入）- 详见 `test_failure_multi_tier_fix.md`
>
> **何时升级到高级策略**：
> - ✅ 单层修复 3 次都失败
> - ✅ 问题涉及多个文件或模块
> - ✅ 前端/UI 相关问题（Gemini 更擅长）
> - ✅ 复杂的后端逻辑问题
> - ✅ 需要更高的成功率保障（100% vs 60-70%）

---

# 第一部分：Claude 执行指南

## 概述

当测试失败时，Claude 作为协调者，负责分析失败原因、生成修复 Prompt、委托 Coder 修复、验证结果，并控制重试循环。

## 核心原则

1. **安全第一**：最大重试 3 次，避免无限循环
2. **智能分析**：使用错误分类系统判断是否可自动修复
3. **渐进式修复**：每次修复后立即验证，失败则重新分析
4. **人工介入点**：超过最大重试次数后停止，请求人工介入
5. **完整记录**：记录所有修复尝试和结果

## 适用场景判断

### ✅ 可自动修复

- 简单的代码逻辑错误
- 类型错误（类型不匹配、参数类型错误）
- 断言失败（预期值与实际值不匹配）
- 边界条件处理不当
- 返回值错误

### ❌ 不可自动修复

- 架构级问题（需要重新设计、涉及多个模块）
- 环境问题（依赖缺失、配置错误）
- 复杂的业务逻辑错误

## 执行步骤

### 步骤 1：捕获测试失败信息

**Claude 需要收集**：
- 失败的测试用例名称（如 `tests/test_calculator.py::test_add`）
- 完整的错误信息和堆栈跟踪
- 测试输出的最后 50 行
- 相关源代码文件路径

**执行命令示例**：
```bash
pytest tests/test_module.py::test_function -v
```

### 步骤 2：错误分类和可修复性判断

**Claude 需要判断**：
1. 参考 `ai/error-handling/error_classification.md` 判断错误类型
2. 是否属于"代码错误"类型？
3. 是否属于"简单代码错误"（逻辑、类型、断言）？
4. **【新增】评估修复置信度**（见步骤 2.1）

**判断流程**：
```
错误类型 == 代码错误？
  ↓ 是
是简单代码错误？
  ↓ 是
评估修复置信度（步骤 2.1）
  ↓
置信度 ≥ 0.5？
  ↓ 是
✅ 可以自动修复，继续步骤 3
  ↓ 否
❌ 不可自动修复，提供修复建议并等待人工处理
```

### 步骤 2.1：修复置信度评估（新增）

**目的**：在开始修复前，评估自动修复的成功概率，避免无效尝试。

**置信度评估矩阵**：

| 错误特征 | 置信度分数 | 说明 |
|---------|----------|------|
| **错误类型** | | |
| 简单断言失败（预期值 vs 实际值） | +0.3 | 最容易修复 |
| 类型错误（类型不匹配） | +0.2 | 通常需要类型转换 |
| 属性错误（AttributeError） | +0.1 | 可能是拼写或逻辑问题 |
| 逻辑错误（返回值错误） | +0.2 | 需要理解业务逻辑 |
| 导入错误（ImportError） | +0.1 | 可能是环境问题 |
| **错误信息清晰度** | | |
| 错误信息非常明确 | +0.2 | 如 "Expected 5, got 6" |
| 错误信息模糊 | -0.1 | 如 "Unexpected behavior" |
| **堆栈跟踪完整性** | | |
| 完整的堆栈跟踪 | +0.1 | 可以定位问题 |
| 堆栈跟踪缺失 | -0.2 | 难以定位 |
| **代码复杂度** | | |
| 单个函数，< 20 行 | +0.2 | 简单易修复 |
| 单个函数，20-50 行 | +0.1 | 中等复杂度 |
| 多个函数/模块 | -0.2 | 可能涉及架构 |
| **历史修复记录**（如果有） | | |
| 之前修复过类似问题 | +0.2 | 有经验 |
| 之前修复失败过 | -0.3 | 可能是复杂问题 |

**置信度计算公式**：
```
初始置信度 = 0.5（基线）
最终置信度 = 初始置信度 + Σ(特征分数)
置信度范围：[0.0, 1.0]
```

**置信度等级和决策**：

| 置信度范围 | 等级 | 决策 | 行动 |
|-----------|------|------|------|
| 0.8 - 1.0 | 🟢 高 | 自动修复 | 直接执行，无需特别说明 |
| 0.5 - 0.79 | 🟡 中 | 谨慎修复 | 向用户报告置信度，自动执行 |
| 0.0 - 0.49 | 🔴 低 | 停止修复 | 提供分析和建议，等待人工介入 |

**评估示例**：

**示例 1：简单断言失败**
```
错误信息："AssertionError: assert 5 == 6"
计算：
  + 0.3（简单断言失败）
  + 0.2（错误信息明确）
  + 0.1（完整堆栈跟踪）
  + 0.2（单个函数 < 20 行）
= 0.5 + 0.8 = 1.3 → 限制为 1.0
等级：🟢 高置信度 → 自动修复
```

**示例 2：类型错误（模糊）**
```
错误信息："TypeError: unsupported operand"（未明确指出类型）
计算：
  + 0.2（类型错误）
  - 0.1（错误信息模糊）
  + 0.1（完整堆栈跟踪）
  + 0.1（20-50 行函数）
= 0.5 + 0.3 = 0.8
等级：🟢 高置信度 → 自动修复（但需谨慎）
```

**示例 3：复杂逻辑错误**
```
错误信息："AssertionError"（无详细信息）
计算：
  + 0.2（逻辑错误）
  - 0.1（错误信息模糊）
  - 0.2（堆栈跟踪缺失）
  - 0.2（多个函数/模块）
= 0.5 - 0.3 = 0.2
等级：🔴 低置信度 → 停止修复，等待人工介入
```

### 步骤 3：分析失败原因

**Claude 需要执行**：
1. 使用 Read 工具读取失败的测试用例代码
2. 使用 Read 工具读取被测试的源代码
3. 分析错误信息和堆栈跟踪
4. 识别问题根源（如：返回值错误、类型不匹配、边界条件未处理）

**分析要点**：
- 测试期望什么？（预期值）
- 代码实际返回什么？（实际值）
- 差异的根本原因是什么？

### 步骤 4：生成修复 Prompt

**Claude 需要生成的 Prompt 模板**：

```
测试失败自动修复任务（第 {retry_count} 次尝试）

**失败测试**：{test_name}
**错误类型**：{error_type}
**错误信息**：
{error_message}

**根本原因分析**：
{root_cause_analysis}

**需要修复的文件**：{file_path}

**修复要求**：
1. 修复 {file_path} 中的 {function_or_class_name}
2. 具体修复内容：{specific_fix_description}
3. 确保修复后测试通过
4. 不要修改测试用例本身
5. 保持代码风格一致

**验证方式**：
运行测试命令：{test_command}
```

**Prompt 生成要点**：
- 明确指出问题根源
- 提供具体的修复方向
- 如果是第 2/3 次尝试，说明之前的尝试为什么失败
- 保持 Prompt 简洁但信息完整

### 步骤 5：调用 Coder 执行修复

**Claude 需要执行**：

使用 `mcp__ccg__coder` 工具调用 Coder：

```json
{
  "PROMPT": "生成的修复 Prompt",
  "cd": "项目根目录路径",
  "SESSION_ID": "保持与之前相同的 SESSION_ID",
  "timeout": 900,
  "max_duration": 900
}
```

**关键点**：
- 必须保持相同的 SESSION_ID，让 Coder 了解修复历史
- 超时设置为 15 分钟（900 秒）
- 等待 Coder 完成修复

### 步骤 6：验证修复结果

**Claude 需要执行**：

1. 使用 Bash 工具重新运行测试：
```bash
pytest tests/test_module.py::test_function -v
```

2. 检查测试结果：
   - ✅ 测试通过 → 修复成功，跳转到步骤 8（报告成功）
   - ❌ 测试失败 → 继续步骤 6.1（动态置信度评估）

### 步骤 6.1：动态置信度评估（新增）

**目的**：修复失败后，评估继续修复的可行性，避免无效重试。

**评估指标**：

| 失败特征 | 置信度变化 | 说明 |
|---------|----------|------|
| **测试通过数变化** | | |
| 通过的测试数增加 | 🟢 +0.3 | 修复方向正确 |
| 通过的测试数不变 | 🟡 0 | 修复可能无效 |
| 通过的测试数减少 | 🔴 -0.5 | 问题加重 |
| **错误信息变化** | | |
| 错误信息改变（不同类型） | 🟡 +0.1 | 有进展 |
| 错误信息改变（同类型） | 🟡 0 | 部分进展 |
| 错误信息完全相同 | 🔴 -0.3 | 修复无效 |
| **新增失败** | | |
| 出现新的测试失败 | 🔴 -0.5 | 问题加重 |
| 无新增失败 | 🟢 +0.1 | 稳定修复 |
| **修复尝试次数** | | |
| 第 1 次失败 | 🟡 0 | 正常 |
| 第 2 次失败 | 🟡 -0.1 | 需要谨慎 |
| 第 3 次失败 | 🔴 -0.3 | 接近极限 |

**动态置信度计算**：
```
新置信度 = 初始置信度（步骤 2.1） + Σ(失败特征分数)
置信度范围：[0.0, 1.0]
```

**继续修复决策矩阵**：

| 新置信度 | 重试次数 | 决策 | 行动 |
|---------|---------|------|------|
| ≥ 0.6 | 1-2 | ✅ 继续修复 | 自动重试 |
| 0.3-0.59 | 1 | ⚠️ 谨慎重试 | 向用户报告，询问是否继续 |
| 0.3-0.59 | 2 | ❌ 停止修复 | 置信度不足，人工介入 |
| < 0.3 | 任何 | ❌ 立即停止 | 问题加重或无效修复 |

**评估示例**：

**示例 1：修复有进展**
```
第 1 次修复失败：
  - 通过测试数：5/10 → 7/10（+2）
  - 错误信息：TypeError → AssertionError（类型改变）
  - 无新增失败

动态置信度计算：
  初始置信度：0.7（高）
  + 0.3（通过数增加）
  + 0.1（错误类型改变）
  + 0.1（无新增失败）
  = 0.7 + 0.5 = 1.2 → 限制为 1.0

决策：🟢 高置信度 → 继续修复（第 2 次）
```

**示例 2：修复无效**
```
第 2 次修复失败：
  - 通过测试数：7/10 → 7/10（不变）
  - 错误信息：AssertionError（完全相同）
  - 无新增失败

动态置信度计算：
  初始置信度：0.7（高）
  + 0（通过数不变）
  - 0.3（错误相同）
  + 0.1（无新增失败）
  - 0.1（第 2 次失败）
  = 0.7 - 0.3 = 0.4

决策：⚠️ 中等置信度 + 重试 2 次 → ❌ 停止修复，人工介入
```

**示例 3：问题加重**
```
第 1 次修复失败：
  - 通过测试数：7/10 → 5/10（-2）
  - 新增 2 个测试失败

动态置信度计算：
  初始置信度：0.7（高）
  - 0.5（通过数减少）
  - 0.5（新增失败）
  = 0.7 - 1.0 = -0.3 → 限制为 0.0

决策：🔴 极低置信度 → ❌ 立即停止，问题加重
```

**Claude 执行动作**：

1. **高置信度（≥ 0.6）**：
   ```
   继续步骤 7（重试逻辑控制）
   ```

2. **中等置信度（0.3-0.59）+ 第 1 次**：
   ```
   向用户报告：

   ⚠️ 修复进展有限，置信度：0.4

   **修复效果**：
   - 通过测试数未增加
   - 错误信息相同

   **当前重试次数**：1/3

   **您的选择**：
   1. 继续尝试自动修复（最多再试 2 次）
   2. 停止自动修复，由我详细分析问题
   3. 停止任务，您亲自修复

   请选择：
   ```

3. **低置信度（< 0.3）或问题加重**：
   ```
   ❌ 检测到问题加重，立即停止自动修复

   **问题恶化迹象**：
   - 通过测试数从 7 个减少到 5 个
   - 新增 2 个测试失败

   **分析**：
   当前的修复方向可能是错误的，继续尝试可能会进一步破坏代码。

   **建议**：
   1. 回滚到修复前的状态（git stash pop）
   2. 重新分析问题根源
   3. 或者调用 Codex 进行深度诊断

   请告诉我您希望如何处理？
   ```

### 步骤 7：重试逻辑控制（增强）

**Claude 需要判断**：

```
步骤 6.1 动态置信度评估结果？
  ↓
┌─────────────────────────────────┐
│ 置信度 ≥ 0.6？                   │
└─────────────────────────────────┘
  ↓ 是              ↓ 否
继续重试判断      停止或询问用户
  ↓
┌─────────────────────────────────┐
│ 当前重试次数 < 3？                │
└─────────────────────────────────┘
  ↓ 是              ↓ 否
自动重试          停止修复
  ↓                  ↓
记录本次失败      生成人工介入报告
重试次数 + 1
返回步骤 3
```

**重试时的注意事项**：
- 保持相同的 SESSION_ID
- 在新的 Prompt 中说明之前的尝试为什么失败
- 提供不同的修复方向

### 步骤 8：报告修复成功

**Claude 需要输出**：

```
✅ 测试失败自动修复成功

**失败测试**：{test_name}
**修复尝试次数**：{retry_count} 次
**修复内容**：{fix_summary}
**验证结果**：测试通过

可以继续后续流程（Claude 验收或 Codex 审核）。
```

### 步骤 9：生成人工介入报告

**Claude 需要输出**：

```
❌ 测试失败自动修复失败，需要人工介入

**失败测试**：{test_name}
**尝试次数**：3 次
**最后错误**：{last_error_message}

**修复历史**：
1. 第 1 次尝试：{attempt_1_summary} → 失败原因：{failure_reason_1}
2. 第 2 次尝试：{attempt_2_summary} → 失败原因：{failure_reason_2}
3. 第 3 次尝试：{attempt_3_summary} → 失败原因：{failure_reason_3}

**问题分析**：
{problem_analysis}

**建议**：
- {suggestion_1}
- {suggestion_2}
- {suggestion_3}

请人工分析并修复此问题。
```

## 与 CCG 工作流集成

### 集成点 1：Coder 执行后自动测试

**触发时机**：Coder 完成代码实现后

**Claude 执行流程**：
1. 自动运行测试命令
2. 如果测试失败，判断是否可自动修复
3. 如果可以，启动自动修复循环（步骤 1-9）
4. 修复成功后，继续 Claude 验收流程

**关键点**：
- 保持 Coder 的 SESSION_ID
- 确保上下文连续

### 集成点 2：Claude 验收阶段

**触发时机**：Claude 验收代码质量时发现测试失败

**Claude 执行流程**：
1. 判断是否可自动修复
2. 如果可以，启动自动修复循环
3. 修复成功后，继续验收其他检查项

**验收检查项**：
- ✅ 代码风格符合规范
- ✅ 所有测试通过（如失败则自动修复）
- ✅ 覆盖率达标
- ✅ 无明显代码质量问题

### 集成点 3：Codex 审核前确保测试通过

**触发时机**：准备调用 Codex 审核前

**Claude 执行流程**：
1. 运行完整测试套件
2. 如果测试失败，启动自动修复循环
3. 修复成功后，才调用 Codex 审核

**强制规则**：
- ❌ 禁止在测试失败时调用 Codex 审核
- ✅ 必须先自动修复测试失败
- ✅ 所有测试通过后才能进入审核阶段

## 安全机制和限制

### 硬性限制

1. **最大重试次数：3 次**
   - 超过 3 次自动停止
   - 避免无限循环

2. **单次修复超时：15 分钟**
   - Coder 执行超时限制
   - 超时视为修复失败

3. **禁止修改测试用例**
   - 只修复源代码
   - 保持测试的权威性

### 软性限制

1. **只修复简单代码错误**
   - 不处理架构级问题
   - 不处理环境问题

2. **保持代码风格一致**
   - 遵循现有代码规范
   - 最小化改动范围

3. **保持 SESSION_ID 连续**
   - 让 Coder 了解修复历史
   - 避免重复相同的错误

---

# 第二部分：用户理解案例

> **说明**：以下案例用于帮助用户理解自动修复系统的工作原理，采用简化的叙述方式。

## 案例 1：简单断言失败（一次修复成功）

### 场景描述

用户实现了一个计算器的 `add` 函数，但测试失败了。

### 测试失败信息

```
FAILED tests/test_calculator.py::test_add
AssertionError: assert 5 == 6
Expected: 6, Got: 5
```

### 自动修复过程

**Claude 分析**：
- 测试期望 `add(2, 3)` 返回 6
- 实际返回 5
- 读取源代码发现：`def add(a, b): return a + b - 1`
- 问题：多减了 1

**Claude 生成 Prompt 给 Coder**：
```
修复 src/calculator.py 中的 add 函数，
移除多余的 -1 操作，确保 add(2, 3) 返回 5。
```

**Coder 修复**：
```python
def add(a, b):
    return a + b  # 移除了 -1
```

**Claude 验证**：
- 重新运行测试：✅ 通过
- 修复成功！

### 结果

✅ 第 1 次尝试就修复成功，用户无需手动干预。

## 案例 2：类型错误（需要多次修复）

### 场景描述

用户实现了一个处理用户输入的函数，但没有考虑各种边界情况。

### 第 1 次尝试

**测试失败**：
```
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

**Claude 分析**：参数 b 可能是字符串，需要类型转换

**Coder 修复**：添加 `int(b)` 类型转换

**验证结果**：❌ 仍然失败（None 值导致错误）

### 第 2 次尝试

**Claude 重新分析**：发现 None 值未处理

**Coder 修复**：添加 None 检查

**验证结果**：❌ 仍然失败（空字符串转换失败）

### 第 3 次尝试

**Claude 重新分析**：发现空字符串 `""` 无法转换为 int

**Coder 修复**：添加空字符串默认值处理

**验证结果**：✅ 通过

### 结果

✅ 通过 3 次渐进式修复，最终解决了所有边界情况问题。

## 案例 3：架构级问题（无法自动修复）

### 场景描述

用户的用户注册功能出现数据库并发问题。

### 测试失败信息

```
IntegrityError: duplicate key value violates unique constraint
```

### 自动修复尝试

**第 1 次尝试**：Coder 添加唯一性检查 → ❌ 失败

**第 2 次尝试**：Coder 修改数据库约束 → ❌ 失败

**第 3 次尝试**：Coder 修改事务隔离级别 → ❌ 失败

### Claude 生成人工介入报告

```
❌ 测试失败自动修复失败，需要人工介入

**失败测试**：test_user_authentication
**尝试次数**：3 次

**问题分析**：
问题涉及数据库架构设计和并发控制策略，
超出了简单代码修复的范围。

**建议**：
- 重新设计用户注册流程的并发控制
- 考虑使用分布式锁或乐观锁
- 建议人工分析并发场景
```

### 结果

❌ 达到最大重试次数，系统停止自动修复，等待用户人工处理。

## 总结

### 核心价值

1. **提高开发效率**
   - 自动修复简单代码错误
   - 减少人工干预
   - 加快迭代速度

2. **保证代码质量**
   - 确保测试通过后才继续
   - 禁止提交失败代码
   - 保持测试的权威性

3. **安全可控**
   - 最大重试 3 次
   - 及时请求人工介入
   - 完整的修复记录

### 适用范围

**✅ 适合自动修复**：
- 简单的逻辑错误
- 类型错误和断言失败
- 边界条件处理不当
- 返回值错误

**❌ 不适合自动修复**：
- 架构级问题
- 环境配置问题
- 复杂的业务逻辑错误
- 需要重新设计的问题

### 与其他系统的关系

- **错误分类系统**：`ai/error-handling/error_classification.md` - 判断错误类型
- **重试策略**：`ai/error-handling/retry_strategy.md` - 控制重试逻辑
- **恢复建议**：`ai/error-handling/recovery_suggestions.md` - 提供修复建议
- **测试失败处理**：`ai/testing/test_failure_handling.md` - 标准处理流程

### 使用建议

1. **优先使用自动修复**：对于简单代码错误，让系统自动处理
2. **监控修复效果**：关注自动修复成功率和常见失败类型
3. **及时人工介入**：遇到复杂问题时不要强行自动修复
4. **持续优化**：根据修复历史优化 Prompt 和策略
