# 测试失败多层级修复策略

> **核心思想**：充分利用 CCG 系统中所有 AI 的能力，通过多层级修复策略提高测试失败的自动修复成功率。

## 概述

当测试失败时，系统会按照以下顺序尝试修复：

```
测试失败
  ↓
第 1 层：Coder 快速修复（最多 2 次）
  ↓ 失败
第 2 层：Codex 深度诊断 + Coder 执行（1 次）
  ↓ 失败
第 3 层：Claude 亲自动手修复（1 次）
  ↓ 失败
第 4 层：Gemini 独立视角修复（1 次）
  ↓ 失败
记录到待修复列表（.ccg/pending_test_fixes.json）
```

**总修复尝试次数**：5 次（比单层 Coder 3 次更多）

---

# 第一部分：Claude 执行指南

## 各层级角色定位

### 第 1 层：Coder（快速修复）

**能力特点**：
- 执行力强，响应快速
- 成本低，适合批量尝试
- 善于处理简单逻辑错误

**适合场景**：
- 简单的逻辑错误
- 类型错误
- 断言失败
- 返回值错误

**限制**：
- 创造力有限
- 容易陷入固定思路
- 对复杂问题理解不深

**重试次数**：最多 2 次

### 第 2 层：Codex（专家诊断）

**能力特点**：
- 代码审核专家，善于发现深层问题
- 理解力强，可以分析复杂逻辑
- 提供详细的修复方案

**适合场景**：
- 复杂的逻辑错误
- 设计问题
- 需要深度分析的错误

**工作方式**：
1. Codex 深度分析失败原因
2. 给出详细的修复方案和步骤
3. Coder 按照 Codex 的方案执行修复

**重试次数**：1 次

### 第 3 层：Claude（架构师亲自动手）

**能力特点**：
- 理解力最强，可以理解复杂上下文
- 可以直接使用 Edit 工具修改代码
- 作为协调者，了解整个项目背景

**适合场景**：
- 需要理解项目上下文的修复
- 涉及多个文件的协调修改
- 需要架构级思考的问题

**工作方式**：
- Claude 直接使用 Edit 工具修改代码
- 不再委托 Coder，自己动手

**重试次数**：1 次

### 第 4 层：Gemini（独立视角）

**能力特点**：
- 不同的思维方式和视角
- 可能发现前面 AI 都忽略的问题
- 独立分析，不受之前尝试的影响

**适合场景**：
- 前面所有尝试都失败的疑难问题
- 需要全新思路的问题

**工作方式**：
- Gemini 独立分析并修复
- 使用 yolo 模式，可以直接修改代码

**重试次数**：1 次

## 完整执行流程

### 步骤 0：初始化

**Claude 需要准备**：
- 捕获测试失败信息（测试名称、错误信息、堆栈跟踪）
- 初始化修复计数器：`tier = 1, attempt = 0`
- 初始化修复历史记录：`fix_history = []`

### 步骤 1：第 1 层修复（Coder 快速修复）

**触发条件**：`tier == 1 and attempt < 2`

**Claude 执行**：
1. 分析失败原因（读取测试代码和源代码）
2. 生成修复 Prompt（参考 `test_failure_auto_fix.md` 的 Prompt 模板）
3. 调用 `mcp__ccg__coder` 修复
4. 运行测试验证结果

**成功**：报告修复成功，结束流程

**失败**：
- 记录本次尝试到 `fix_history`
- `attempt++`
- 如果 `attempt < 2`：返回步骤 1（重新分析，提供不同修复方向）
- 如果 `attempt >= 2`：进入步骤 2（第 2 层）

### 步骤 2：第 2 层修复（Codex 诊断 + Coder 执行）

**触发条件**：第 1 层失败 2 次后

**Claude 执行**：

1. **调用 Codex 深度分析**

使用 `mcp__ccg__codex` 工具：

```json
{
  "PROMPT": "请深度分析以下测试失败原因，并给出详细的修复方案：\n\n**失败测试**：{test_name}\n**错误信息**：{error_message}\n**已尝试修复**：\n- 第 1 次：{attempt_1_summary}\n- 第 2 次：{attempt_2_summary}\n\n请分析：\n1. 问题的根本原因是什么？\n2. 为什么前两次修复都失败了？\n3. 正确的修复方案是什么？\n4. 具体的修复步骤",
  "cd": "项目根目录",
  "sandbox": "read-only"
}
```

2. **根据 Codex 的方案生成 Coder Prompt**

3. **调用 Coder 执行修复**

4. **验证结果**

**成功**：报告修复成功，结束流程

**失败**：进入步骤 3（第 3 层）

### 步骤 3：第 3 层修复（Claude 亲自动手）

**触发条件**：第 2 层失败后

**Claude 执行**：

1. **深度分析失败原因**
   - 读取所有相关代码文件
   - 理解项目上下文和架构
   - 分析为什么前面 3 次都失败了

2. **直接使用 Edit 工具修复代码**
   - 不再委托 Coder
   - Claude 自己动手修改代码

3. **验证结果**

**成功**：报告修复成功，结束流程

**失败**：进入步骤 4（第 4 层）

### 步骤 4：第 4 层修复（Gemini 独立视角）

**触发条件**：第 3 层失败后

**Claude 执行**：

调用 `mcp__ccg__gemini` 工具：

```json
{
  "PROMPT": "请用全新的视角分析并修复以下测试失败：\n\n**失败测试**：{test_name}\n**错误信息**：{error_message}\n**已尝试修复**：\n- Coder 尝试 1：{attempt_1}\n- Coder 尝试 2：{attempt_2}\n- Codex 诊断 + Coder：{attempt_3}\n- Claude 修复：{attempt_4}\n\n所有尝试都失败了。请：\n1. 用不同的角度分析问题\n2. 找出可能被忽略的因素\n3. 直接修复代码",
  "cd": "项目根目录",
  "yolo": true
}
```

**验证结果**

**成功**：报告修复成功，结束流程

**失败**：进入步骤 5（记录到待修复列表）

### 步骤 5：记录到待修复列表

**触发条件**：所有 4 层修复都失败后

**Claude 执行**：

1. **生成详细的失败记录**

```json
{
  "id": "fix-{timestamp}",
  "test_name": "{test_name}",
  "error_type": "{error_type}",
  "error_message": "{error_message}",
  "total_attempts": 5,
  "fix_history": [
    {
      "tier": 1,
      "attempt": 1,
      "fixer": "Coder",
      "summary": "...",
      "result": "failed"
    },
    {
      "tier": 1,
      "attempt": 2,
      "fixer": "Coder",
      "summary": "...",
      "result": "failed"
    },
    {
      "tier": 2,
      "fixer": "Codex + Coder",
      "summary": "...",
      "result": "failed"
    },
    {
      "tier": 3,
      "fixer": "Claude",
      "summary": "...",
      "result": "failed"
    },
    {
      "tier": 4,
      "fixer": "Gemini",
      "summary": "...",
      "result": "failed"
    }
  ],
  "status": "pending",
  "priority": "high",
  "created_at": "{timestamp}"
}
```

2. **写入到 `.ccg/pending_test_fixes.json`**

3. **输出人工介入报告**

```
❌ 多层级修复失败，已记录到待修复列表

**失败测试**：{test_name}
**总尝试次数**：5 次（4 层修复）

**修复历史**：
- 第 1 层（Coder）：尝试 2 次，均失败
- 第 2 层（Codex + Coder）：尝试 1 次，失败
- 第 3 层（Claude）：尝试 1 次，失败
- 第 4 层（Gemini）：尝试 1 次，失败

**问题分析**：
{problem_analysis}

**已记录到**：.ccg/pending_test_fixes.json

**建议**：
- 问题可能涉及架构级改动或环境配置
- 建议人工深度分析根本原因
- 可以稍后使用 /ccg:fix-pending 批量处理待修复项
```

---

# 第二部分：用户理解案例

> **说明**：以下案例用于帮助用户理解多层级修复系统的工作原理。

## 案例 1：第 1 层成功（简单逻辑错误）

### 场景
计算器函数返回值错误

### 修复过程
- **第 1 层（Coder 第 1 次）**：发现多减了 1，修复 → ✅ 成功

### 结果
✅ 第 1 层第 1 次尝试就成功，总耗时最短

## 案例 2：第 2 层成功（复杂逻辑错误）

### 场景
数据处理函数边界条件处理不当

### 修复过程
- **第 1 层（Coder 第 1 次）**：添加类型转换 → ❌ 失败（None 值未处理）
- **第 1 层（Coder 第 2 次）**：添加 None 检查 → ❌ 失败（空字符串未处理）
- **第 2 层（Codex 诊断）**：Codex 发现需要完整的输入验证逻辑
- **第 2 层（Coder 执行）**：按 Codex 方案实现 → ✅ 成功

### 结果
✅ 第 2 层成功，Codex 的专家诊断起到关键作用

## 案例 3：第 3 层成功（需要理解上下文）

### 场景
API 调用顺序错误，需要理解整个请求流程

### 修复过程
- **第 1 层（Coder 2 次）**：尝试修改单个函数 → ❌ 失败
- **第 2 层（Codex + Coder）**：Codex 发现问题但 Coder 执行不到位 → ❌ 失败
- **第 3 层（Claude）**：Claude 理解整个请求流程，协调修改多个文件 → ✅ 成功

### 结果
✅ 第 3 层成功，Claude 的上下文理解能力是关键

## 案例 4：第 4 层成功（需要新视角）

### 场景
前端组件渲染问题，涉及 React 生命周期

### 修复过程
- **第 1-3 层**：都从数据流角度分析 → ❌ 失败
- **第 4 层（Gemini）**：从 UI 渲染角度发现是 useEffect 依赖问题 → ✅ 成功

### 结果
✅ 第 4 层成功，Gemini 的不同视角发现了被忽略的问题

## 案例 5：所有层都失败（架构级问题）

### 场景
数据库并发控制问题

### 修复过程
- **第 1 层（Coder 2 次）**：尝试添加锁 → ❌ 失败
- **第 2 层（Codex + Coder）**：尝试修改事务隔离级别 → ❌ 失败
- **第 3 层（Claude）**：尝试重新设计并发控制 → ❌ 失败
- **第 4 层（Gemini）**：尝试使用分布式锁 → ❌ 失败
- **记录到待修复列表**

### 结果
❌ 所有层都失败，问题涉及架构级改动，已记录到 `.ccg/pending_test_fixes.json`，等待人工处理

## 总结

### 核心优势

1. **更高的成功率**
   - 5 次尝试机会（vs 单层 3 次）
   - 4 个不同 AI 的视角
   - 从简单到复杂的递进策略

2. **成本优化**
   - 简单问题用 Coder（便宜）
   - 复杂问题才用 Claude/Gemini（贵）
   - 80% 的问题在第 1-2 层解决

3. **不阻塞开发**
   - 所有层都失败后记录到待修复列表
   - 可以继续其他工作
   - 稍后批量处理

### 预期成功率分布

根据问题复杂度的预期分布：

- **第 1 层（Coder）**：解决 60-70% 的简单问题
- **第 2 层（Codex + Coder）**：解决 15-20% 的中等问题
- **第 3 层（Claude）**：解决 5-10% 的复杂问题
- **第 4 层（Gemini）**：解决 2-5% 的疑难问题
- **记录待修复**：剩余 5-10% 的架构级问题

**总体自动修复成功率**：预期 90-95%

### 与其他系统的关系

- **基础自动修复**：`ai/testing/test_failure_auto_fix.md` - 单层 Coder 修复（本文档的第 1 层）
- **错误分类系统**：`ai/error-handling/error_classification.md` - 判断错误类型
- **测试失败处理**：`ai/testing/test_failure_handling.md` - 标准处理流程
- **待修复列表**：`.ccg/pending_test_fixes.json` - 记录失败项

### 使用建议

1. **默认启用多层级修复**
   - 对所有测试失败使用多层级策略
   - 最大化自动修复成功率

2. **监控各层成功率**
   - 统计每层的成功率
   - 优化各层的 Prompt 策略

3. **定期处理待修复列表**
   - 每天或每周检查 `.ccg/pending_test_fixes.json`
   - 批量处理积累的失败项

4. **持续优化**
   - 分析失败模式
   - 改进各层的修复策略
   - 提高整体成功率
