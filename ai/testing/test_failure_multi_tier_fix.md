# 测试失败多层级修复策略

> **核心思想**：充分利用 CCG 系统中所有 AI 的能力，通过智能诊断、按领域分流、3 层自动修复（每层 3 次重试）和人工介入，实现真正的 100% 问题解决率。

## 概述

当测试失败时，系统会按照以下顺序尝试修复：

```
测试失败
  ↓
步骤 0：智能诊断（1-2 分钟）
  - 分析失败类型（简单/复杂）
  - 识别问题领域（前端/后端/全栈）
  - 收集相关上下文
  - 确认需求理解
  ↓
复杂问题（20%）→ 直接进入第 4 层人工介入
  ↓
简单问题（80%）→ 按领域分流进入自动修复：

  【前端问题】（30%）
    第 1 层：Gemini 前端专家（最多 3 次）
      ↓ 失败
    第 2 层：Codex + Coder 深度诊断（最多 3 次）
      ↓ 失败
    第 3 层：Claude 亲自动手（最多 3 次）
      ↓ 失败

  【后端问题】（50%）
    第 1 层：Codex + Coder 深度诊断（最多 3 次）
      ↓ 失败
    第 2 层：Gemini 独立视角（最多 3 次）
      ↓ 失败
    第 3 层：Claude 亲自动手（最多 3 次）
      ↓ 失败

  【全栈问题】（20%）
    第 1 层：Codex + Coder 深度诊断（最多 3 次）
      ↓ 失败
    第 2 层：Gemini 独立视角（最多 3 次）
      ↓ 失败
    第 3 层：Claude 亲自动手（最多 3 次）
      ↓ 失败
  ↓
第 4 层：人工介入（5 分钟超时）
  - 5 分钟内响应 → 人工解决 → 100%
  - 5 分钟无响应 → 记录并跳过 → 继续其他任务
```

**总修复尝试次数**：9 次自动 + 人工介入
**预期成功率**：100%（自动 96-99% + 人工 100%）
**核心优势**：按问题领域分流，优先使用最擅长的 AI 处理

## acemcp 语义搜索的核心价值

在修复过程中，充分利用 `acemcp` 语义搜索能力：

**工具**：`mcp__acemcp__search_context`

**核心优势**：
1. **语义理解**：不只是关键词匹配，而是理解代码的语义关系
2. **自动索引**：搜索前自动增量更新索引，确保结果最新
3. **全面覆盖**：找到所有相关代码，包括辅助函数、工具类、类似实现

**使用场景**：
- 步骤 0：智能诊断时的初步搜索
- 第 1 层：深度搜索相关概念和模式
- 第 2 层：全面理解项目架构
- 第 3 层：独立视角的语义搜索

---

# 第一部分：Claude 执行指南

## 步骤 0：智能诊断（前置步骤）

**目的**：快速判断问题类型和领域，避免浪费时间在错误方向上

**执行时间**：1-2 分钟

### 诊断步骤

**步骤 1：分析失败类型和问题领域**

```python
# 简单问题特征
simple_patterns = [
    "SyntaxError",           # 语法错误
    "NameError",             # 变量名错误
    "TypeError",             # 类型错误
    "AttributeError",        # 属性错误
    "简单的 AssertionError"  # 简单断言失败
]

# 复杂问题特征
complex_patterns = [
    "多个测试同时失败",      # 架构级问题
    "环境配置问题",          # 需要修改配置
    "数据库迁移失败",        # 需要架构调整
    "并发/竞态条件",         # 复杂的并发问题
    "性能问题",              # 需要性能优化
]

# 前端问题特征
frontend_patterns = [
    "UI", "界面", "样式", "CSS", "HTML",
    "React", "Vue", "Angular", "Svelte",
    "DOM", "浏览器", "渲染", "组件",
    "前端", "页面", "布局", "响应式"
]

# 后端问题特征
backend_patterns = [
    "API", "数据库", "SQL", "查询",
    "服务器", "后端", "接口", "端点",
    "认证", "权限", "中间件", "路由",
    "缓存", "队列", "任务", "定时"
]

# 全栈问题特征
fullstack_patterns = [
    "集成", "端到端", "E2E",
    "数据流", "状态管理", "前后端交互",
    "WebSocket", "实时", "同步"
]
```

**步骤 2：使用 acemcp 收集相关上下文**

使用 `mcp__acemcp__search_context` 工具：

```json
{
  "project_root_path": "项目根目录绝对路径",
  "query": "测试失败相关的功能描述，如：user authentication login validation"
}
```

**搜索目标**：
- 失败测试涉及的所有相关代码
- 项目中类似功能的实现参考
- 相关的工具函数和辅助类

**步骤 3：确认需求理解**

- 读取测试代码，理解测试意图
- 读取源代码，理解当前实现
- 结合 acemcp 搜索结果，理解项目上下文

**步骤 4：决策和分流**

- **复杂问题** → 直接进入第 4 层人工介入
- **简单问题** → 按领域分流进入自动修复：
  - **前端问题**（30%）→ Gemini → Codex+Coder → Claude
  - **后端问题**（50%）→ Codex+Coder → Gemini → Claude
  - **全栈问题**（20%）→ Codex+Coder → Gemini → Claude

---

## 前端问题修复流程

### 第 1 层：Gemini 前端专家修复

**角色定位**：Gemini 是前端/UI 专家，特别擅长处理前端问题

**能力特点**：
- 深入理解前端框架（React、Vue、Angular 等）
- 精通 UI/UX 和浏览器行为
- 善于处理组件生命周期和状态管理问题

**适合场景**：
- React/Vue/Angular 组件问题
- CSS 样式和布局问题
- DOM 操作和事件处理
- 前端状态管理问题

**重试次数**：最多 3 次

**执行步骤**：

1. **使用 acemcp 搜索前端相关代码**

```json
{
  "project_root_path": "项目根目录绝对路径",
  "query": "前端组件 UI 渲染 样式 [具体问题关键词]"
}
```

2. **调用 Gemini 修复**

使用 `mcp__ccg__gemini` 工具：

```json
{
  "PROMPT": "请修复以下前端测试失败：\n\n**失败测试**：{test_name}\n**错误信息**：{error_message}\n**问题领域**：前端/UI\n\n**相关代码上下文**（来自 acemcp 搜索）：\n{acemcp_context}\n\n请分析并修复问题。",
  "cd": "项目根目录",
  "yolo": true
}
```

3. **运行测试验证结果**

**成功**：报告修复成功，结束流程

**失败**：
- 记录本次尝试到 `fix_history`
- `attempt++`
- 如果 `attempt < 3`：返回步骤 1（重新分析，提供不同修复方向）
- 如果 `attempt >= 3`：进入第 2 层（Codex + Coder）

### 第 2 层：Codex 深度诊断 + Coder 执行

**角色定位**：Codex 提供深度诊断，Coder 执行修复

**触发条件**：第 1 层（Gemini）失败 3 次后

**执行步骤**：

1. **使用 acemcp 深度搜索**

```json
{
  "project_root_path": "项目根目录绝对路径",
  "query": "扩展的搜索查询，包含错误信息关键词和相关概念"
}
```

2. **调用 Codex 深度分析**

使用 `mcp__ccg__codex` 工具：

```json
{
  "PROMPT": "请深度分析以下前端测试失败原因，并给出详细的修复方案：\n\n**失败测试**：{test_name}\n**错误信息**：{error_message}\n**已尝试修复**（Gemini 3次）：\n- 第 1 次：{attempt_1_summary}\n- 第 2 次：{attempt_2_summary}\n- 第 3 次：{attempt_3_summary}\n\n**相关代码上下文**（来自 acemcp 搜索）：\n{acemcp_context}\n\n请分析：\n1. 问题的根本原因是什么？\n2. 为什么 Gemini 的 3 次修复都失败了？\n3. 正确的修复方案是什么？\n4. 具体的修复步骤",
  "cd": "项目根目录",
  "sandbox": "read-only"
}
```

3. **根据 Codex 的方案生成 Coder Prompt**

4. **调用 Coder 执行修复**

5. **验证结果**

**成功**：报告修复成功，结束流程

**失败**：
- 记录本次尝试
- `attempt++`
- 如果 `attempt < 3`：返回步骤 1
- 如果 `attempt >= 3`：进入第 3 层（Claude）

### 第 3 层：Claude 亲自动手修复

**角色定位**：Claude 作为架构师，理解力最强，直接修复

**触发条件**：第 2 层失败 3 次后

**执行步骤**：

1. **使用 acemcp 全面搜索**

```json
{
  "project_root_path": "项目根目录绝对路径",
  "query": "全面的搜索查询，包含所有相关概念和模式"
}
```

2. **深度分析失败原因**
   - 读取所有相关代码文件
   - 结合 acemcp 搜索结果理解项目架构
   - 分析为什么前面 6 次都失败了

3. **直接使用 Edit 工具修复代码**
   - 不再委托 Coder
   - Claude 自己动手修改代码

4. **验证结果**

**成功**：报告修复成功，结束流程

**失败**：进入第 4 层（人工介入）

---

## 后端问题修复流程

### 第 1 层：Codex 深度诊断 + Coder 执行

**角色定位**：Codex 是后端专家，擅长 API、数据库、服务器端逻辑

**能力特点**：
- 深入理解后端架构和设计模式
- 精通数据库查询和优化
- 善于处理 API 设计和服务器端逻辑

**适合场景**：
- API 接口问题
- 数据库查询和事务问题
- 认证和权限问题
- 中间件和路由问题

**重试次数**：最多 3 次

**执行步骤**：参考前端流程第 2 层的详细步骤

### 第 2 层：Gemini 独立视角修复

**角色定位**：Gemini 提供不同视角，可能发现 Codex 忽略的问题

**触发条件**：第 1 层（Codex + Coder）失败 3 次后

**重试次数**：最多 3 次

**执行步骤**：参考前端流程第 1 层的详细步骤

### 第 3 层：Claude 亲自动手修复

**角色定位**：Claude 作为最终兜底，直接修复

**触发条件**：第 2 层失败 3 次后

**重试次数**：最多 3 次

**执行步骤**：参考前端流程第 3 层的详细步骤

---

## 全栈问题修复流程

全栈问题的修复流程与后端问题相同：

### 第 1 层：Codex 深度诊断 + Coder 执行
**重试次数**：最多 3 次

### 第 2 层：Gemini 独立视角修复
**重试次数**：最多 3 次

### 第 3 层：Claude 亲自动手修复
**重试次数**：最多 3 次

---

## 第 4 层：人工介入（最终保障）

**角色**：人工专家
**超时时间**：5 分钟
**成功率**：100%

**触发条件**：
- 复杂问题（步骤 0 诊断为复杂）
- 所有 3 层自动修复都失败

### 执行步骤

**步骤 1：生成人工介入报告**

```markdown
🚨 需要人工介入

**失败测试**：{test_name}
**问题领域**：{domain}（前端/后端/全栈）
**问题复杂度**：{complexity}（简单/复杂）

**已尝试修复**：
- 第 1 层（{layer1_role}）：尝试 3 次，均失败
- 第 2 层（{layer2_role}）：尝试 3 次，均失败
- 第 3 层（Claude）：尝试 3 次，均失败

**问题分析**：
{problem_analysis}

**建议修复方向**：
{suggested_directions}

**等待人工响应**（5 分钟超时）...
```

**步骤 2：等待人工响应**

- 设置 5 分钟计时器
- 等待用户输入修复方案或直接修复

**步骤 3：处理响应**

**情况 A：5 分钟内收到响应**
- 按照人工指示修复
- 验证修复结果
- 成功率：100%

**情况 B：5 分钟无响应**
- 记录问题到 `.ccg/pending_test_fixes.json`
- 输出跳过通知
- 继续处理其他任务

---

# 第二部分：用户理解案例

> **说明**：以下案例用于帮助用户理解按领域分流的多层级修复系统的工作原理。

## 案例 1：前端问题 - 第 1 层成功（Gemini）

### 场景
React 组件渲染问题，useEffect 依赖数组配置错误

### 修复过程
- **步骤 0**：智能诊断识别为前端问题（React 组件）
- **第 1 层（Gemini 第 1 次）**：发现 useEffect 依赖缺失，添加依赖 → ✅ 成功

### 结果
✅ 第 1 层第 1 次尝试就成功，Gemini 的前端专长发挥作用

## 案例 2：后端问题 - 第 1 层成功（Codex + Coder）

### 场景
API 接口返回数据格式错误

### 修复过程
- **步骤 0**：智能诊断识别为后端问题（API 接口）
- **第 1 层（Codex 诊断）**：发现序列化器配置错误
- **第 1 层（Coder 执行）**：修复序列化器 → ✅ 成功

### 结果
✅ 第 1 层成功，Codex 的后端专长发挥作用

## 案例 3：前端问题 - 第 2 层成功

### 场景
CSS 样式冲突导致布局错乱

### 修复过程
- **步骤 0**：智能诊断识别为前端问题（CSS 样式）
- **第 1 层（Gemini 3 次）**：尝试修改 CSS → ❌ 失败（未发现样式优先级问题）
- **第 2 层（Codex 诊断）**：发现 CSS 优先级冲突
- **第 2 层（Coder 执行）**：使用更具体的选择器 → ✅ 成功

### 结果
✅ 第 2 层成功，Codex 的深度诊断发现了 Gemini 忽略的问题

## 案例 4：后端问题 - 第 3 层成功（Claude）

### 场景
数据库事务处理错误，涉及多个表的协调

### 修复过程
- **步骤 0**：智能诊断识别为后端问题（数据库事务）
- **第 1 层（Codex + Coder 3 次）**：尝试修改单个事务 → ❌ 失败
- **第 2 层（Gemini 3 次）**：尝试不同的事务策略 → ❌ 失败
- **第 3 层（Claude）**：理解整个数据流，重新设计事务边界 → ✅ 成功

### 结果
✅ 第 3 层成功，Claude 的架构理解能力是关键

## 案例 5：复杂问题 - 人工介入

### 场景
分布式系统并发控制问题

### 修复过程
- **步骤 0**：智能诊断识别为复杂问题（并发控制）
- **直接进入第 4 层**：生成人工介入报告
- **人工响应**（3 分钟内）：提供分布式锁方案
- **Claude 执行**：按照人工方案实施 → ✅ 成功

### 结果
✅ 人工介入成功，100% 解决率保障

---

## 总结

### 核心优势

1. **按领域分流，精准匹配**
   - 前端问题优先用 Gemini（UI 专家）
   - 后端问题优先用 Codex（后端专家）
   - 充分发挥每个 AI 的专长

2. **更高的成功率**
   - 9 次自动尝试机会（每层 3 次）
   - 4 个不同 AI 的视角
   - 从简单到复杂的递进策略
   - 人工介入保障 100% 解决率

3. **成本优化**
   - 简单问题在第 1 层解决（成本低）
   - 复杂问题才升级到更高层
   - 80% 的问题在前 2 层解决

4. **不阻塞开发**
   - 人工介入 5 分钟超时
   - 无响应时记录并跳过
   - 可以继续其他工作

5. **acemcp 语义搜索增强**
   - 每层修复前使用语义搜索
   - 理解项目中类似功能的实现模式
   - 提供更全面的上下文

### 预期成功率分布

根据问题复杂度和领域的预期分布：

**前端问题（30%）**：
- 第 1 层（Gemini）：解决 85-90%
- 第 2 层（Codex + Coder）：解决 8-12%（累计 93-97%）
- 第 3 层（Claude）：解决 3-5%（累计 96-99%）

**后端问题（50%）**：
- 第 1 层（Codex + Coder）：解决 85-90%
- 第 2 层（Gemini）：解决 8-12%（累计 93-97%）
- 第 3 层（Claude）：解决 3-5%（累计 96-99%）

**全栈问题（20%）**：
- 第 1 层（Codex + Coder）：解决 85-90%
- 第 2 层（Gemini）：解决 8-12%（累计 93-97%）
- 第 3 层（Claude）：解决 3-5%（累计 96-99%）

**人工介入**：剩余 1-4% + 复杂问题（20%）→ 100%

**总体成功率**：100%（自动 96-99% + 人工 100%）

### 与其他系统的关系

- **基础自动修复**：`ai/testing/test_failure_auto_fix.md` - 单层 Coder 修复（适合简单问题）
- **错误分类系统**：`ai/error-handling/error_classification.md` - 判断错误类型
- **测试失败处理**：`ai/testing/test_failure_handling.md` - 标准处理流程
- **待修复列表**：`.ccg/pending_test_fixes.json` - 记录跳过的问题

### 使用建议

1. **默认启用多层级修复**
   - 对所有测试失败使用多层级策略
   - 最大化自动修复成功率

2. **监控各层成功率**
   - 统计每层的成功率
   - 优化各层的 Prompt 策略

3. **定期处理待修复列表**
   - 每天或每周检查 `.ccg/pending_test_fixes.json`
   - 批量处理积累的跳过项

4. **持续优化**
   - 分析失败模式
   - 改进各层的修复策略
   - 提高整体成功率

