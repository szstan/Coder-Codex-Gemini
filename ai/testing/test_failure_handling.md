# 测试失败处理指南

## 概述

测试失败是开发过程中的正常现象，关键是如何快速定位问题并有效修复。本指南提供测试失败后的标准处理流程。

## 核心原则

1. **测试失败必须修复**：不允许跳过或忽略失败的测试
2. **禁止提交失败代码**：测试未通过不允许提交到代码库
3. **根因分析优先**：找到真正的问题根源，而不是修改测试来"通过"
4. **自动化优先**：优先运行自动化测试，快速反馈

## 测试失败分类

### 1. 代码错误导致的失败

**特征**：
- 功能实现有 bug
- 逻辑错误
- 边界条件处理不当

**处理策略**：
- ✅ 修复代码实现
- ✅ 重新运行测试验证
- ❌ 不要修改测试用例来"通过"

### 2. 测试用例问题

**特征**：
- 测试用例编写错误
- 断言条件不正确
- 测试数据有误

**处理策略**：
- ✅ 修复测试用例
- ✅ 确保测试真实反映需求
- ✅ 重新运行验证

### 3. 环境问题

**特征**：
- 依赖缺失
- 配置错误
- 数据库状态不一致

**处理策略**：
- ✅ 修复环境配置
- ✅ 重置测试环境
- ✅ 验证环境就绪后重新测试

## 标准处理流程

### 步骤 1：捕获测试失败信息

**收集信息**：
- 失败的测试用例名称
- 错误信息和堆栈跟踪
- 测试日志输出
- 失败时的环境状态

### 步骤 2：分析失败原因

**决策树**：
```
测试失败
    ↓
检查错误信息
    ↓
是代码错误？
  ↓ 是 → 修复代码
  ↓ 否 → 继续
是测试用例问题？
  ↓ 是 → 修复测试
  ↓ 否 → 继续
是环境问题？
  ↓ 是 → 修复环境
```

### 步骤 3：执行修复

**代码错误修复**：
1. 定位错误代码位置
2. 分析错误原因
3. 修复代码实现
4. 本地验证修复

**测试用例修复**：
1. 检查测试逻辑
2. 修正断言条件
3. 更新测试数据
4. 验证测试正确性

**环境问题修复**：
1. 检查依赖是否完整
2. 验证配置是否正确
3. 重置测试环境
4. 确认环境就绪

### 步骤 4：重新运行测试

**验证修复**：
```bash
# 运行失败的测试
pytest tests/test_module.py::test_function -v

# 运行完整测试套件
pytest tests/ -v
```

### 步骤 5：确认通过后才能继续

**检查点**：
- ✅ 所有测试通过
- ✅ 覆盖率达标
- ✅ 无新增失败测试

**禁止行为**：
- ❌ 跳过失败的测试
- ❌ 注释掉失败的测试
- ❌ 测试未通过就提交代码

## CCG 工作流中的测试失败处理

### Coder 执行后测试失败

**流程**：
1. Coder 完成代码实现
2. 自动运行测试
3. 测试失败 → 停止流程

**Claude 处理**：
1. 分析测试失败原因
2. 判断是代码错误还是测试问题
3. 委托 Coder 修复或自行修复
4. 重新运行测试验证

### 测试通过后的流程

**继续流程**：
1. 所有测试通过
2. Claude 验收代码质量
3. 调用 Codex 审核
4. 审核通过后提交代码

## 常见测试失败场景

### 场景 1：单元测试失败

**示例**：
```
FAILED tests/test_user.py::test_create_user - AssertionError
Expected: 201, Got: 500
```

**处理**：
1. 检查 create_user 函数实现
2. 修复返回状态码错误
3. 重新运行测试

### 场景 2：集成测试失败

**示例**：
```
FAILED tests/test_integration.py::test_api_flow
Database connection failed
```

**处理**：
1. 检查数据库连接配置
2. 确认测试数据库已启动
3. 重置测试数据库
4. 重新运行测试

## 总结

测试失败处理的关键原则：
1. **必须修复**：不允许跳过或忽略
2. **根因分析**：找到真正的问题
3. **验证修复**：重新运行测试确认
4. **禁止提交**：测试未通过不允许提交
